---
title: 多线程学习(二)：Java内存模型
date: 2018-11-13 16:20:30
categories:
- Java多线程
tags:
- Java
- 多线程
---

> 学习Java并发编程的艺术。
> 本章节的主要目的是对内存模型相关知识点做一个笔记。

## 参考书籍

 **Java并发编程的艺术**
 
<!-- more -->

## 基础概念

### 并发编程中的两个关键问题

 **线程如何通信**
 
 通信是指线程之间以何种机制来交换信息，线程之间的通信机制有两种：共享内存和消息传递。
 
 Java并发采用的共享内存模型，线程通信通过读-写内存中的公共状态来隐式通信。消息传递是发送消息来进行显式通信。
 
 **线程间如何同步**
 
 同步是指程序中用于控制不同线程间操作发生相对顺序的机制。共享内存中，开发者需要显式的指定某个方法或某段代码需要在线程间互斥执行，是显式的。
 
 消息传递则是隐式的。 

### Java内存模型概念 

 **什么是内存模型**
 
 内存模型（Java-Memory-Model简称JMM），是用作控制Java线程通信的。
 
 Java中的实例变量、静态变量和数组元素（准确来说是实例域、静态域）都存储在堆中，堆内存是线程共享的。这里把这些统称为共享变量。JMM的作用就是决定线程对共享变量的写入何时对另一线程可见。
 
 ![](http://pbsg2r9io.bkt.clouddn.com/18-11-13/31460366.jpg)
 
 如图所示，线程间通信时，JMM控制线程1更新变量时把本地内存刷新到主内存，线程2在读取时去读取主内存已更新的变量。通过主内存与线程本地内存的交互来确保线程间的内存可见性。
 
 **重排序**
 
 为提高性能，编译器和处理器常常会对指令做重排序（编译器优化重排序、指令重排序与内存系统重排序），重排序在多线程程序中可能导致内存可见性的问题。
 
 JMM的重排序规则禁止特定类型的编译器和处理器重排序，为程序提供一致的内存可见性保证。
 
 **Happen-Before原则**
 
 1. 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
 2. 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
 3. volatile变量规则：对一个volatile的写，happens-before于任意后续对这个volatile域的读。
 4. 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
 5. start()规则：线程的start方法happens-before此线程的任意操作。
 6. join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。
 7. 线程中断规则：对线程interrupt()方法的调用happens-before被中断线程的代码检测到中断事件的发生。
 8. 对象结束规则：一个对象的初始化完成happens-before他的finalize()方法的开始。
 