---
title: JVM内存管理
date: 2018-08-06 17:08:32
categories:
- Java虚拟机
tags:
- Java
- JVM
---

  ![](http://pbsg2r9io.bkt.clouddn.com/18-8-6/89580607.jpg)
  
  本文主要目的是从学习**深入理解Java虚拟机**中，针对JVM内存管理做下读书笔记。整理主要从以下几个方面来梳理 JVM的内存区域、JVM的内存溢出、JVM的GC算法、JVM的类加载机制。
  
  <!-- more -->
  
### JVM的内存管理机制

  ![](http://pbsg2r9io.bkt.clouddn.com/18-8-6/99649423.jpg=150*99)
  
  Java堆和方法区是线程共享的数据区，虚拟机栈、本地方法栈和程序计数器则是由线程独有的数据区。
  
  + **程序计数器**：一块较小的内存空间，可以看做当前线程执行字节码的行号指示器。
    + 虚拟机多线程是由线程轮流切换分配CPU的执行权限，为了保证线程切换后能恢复到正确的执行位置，每条线程需要一个独立的程序计数器。 
  + **方法区**：存放加载的类信息和运行时的常量池信息(字符串和数字常量)
  + **Java堆**：虚拟机启动时候创建，是Java程序最主要的内存工作区域。所有的Java对象实例及数组都放在Java堆中。所有线程共享堆内存。
    + 随着JIT编译器的发展和逃逸分析技术的成熟，所有对象分配在堆上的说法也不再绝对。
  + **虚拟机栈**：每个线程私有。保存局部变量、方法参数等。
  + **本地方法栈**：与虚拟机栈类似，供本地方法调用。

#### 对象的创建
  
  `Person p = new Person()`
  
  对象的创建是由一个new指令开始的，程序new一个对象的时候，虚拟机首先检查指令的参数是否在常量池(方法区)定位到一个类引用，并且该类是否已记载、解析、初始化。(如果没有，需要先执行相应的类加载 Chapter7)。
  
  类加载检查完成后，虚拟机为对象分配内存。对象所需内存的大小在类加载完成后可以确定(Chapter2.3.2)。分配方式有指针碰撞与空闲列表两种。
  
  内存分配完成以后，虚拟机需要将分配到的内存空间都初始化为零值。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
  
  接下来，设置对象的对象头信息（对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄）
  
  至此，虚拟机的对象创建已经完成。剩下的就是执行对象init方法进行对象的初始化了。
  
  + 虚拟机分配内存方式：
    + 指针碰撞(Bump the Pointer): 如果堆内存是规整的，空闲内存一边，已使用内存一边，中间一个指针作为分界点。则分配内存仅仅是把指针向空闲空间挪动一段与对象大小相等的距离。
    + 空闲列表(Free List): 如果堆内存是不规整的，就没办法进行简单的指针碰撞了。虚拟机需要维护一个列表记录内存是空闲还是已使用的。分配的时候找到一块足够大的空间划分给对象实例。
  具体选择哪种分配方式由堆内存是否规整决定，堆内存是否规整则由所使用的的垃圾收集器是否带有压缩整理功能决定。这里使用Serial、ParNew等带Compact过程的收集器时，系统采用指针碰撞方式分配，
  而使用CMS的基于Mark-Sweep算法收集器通常采用空闲列表。
  
  + 我们常用的HotSpot采用了那些收集器呢？
  
  + 虚拟机分配内存在并发场景下如何保证线程安全？
  
    对象的创建是个很频繁的操作，即使一个简单的指针位置变动，在并发场景下，可能正在给A对象分配内存，指针没来得及修改，对象B也同时使用同一个指针分配内存。
    
    + CAS失败重试。虚拟机实际上以该方式确保指针更新操作的原子性。
    + 本地线程分配缓冲(Thread Local Allocation Buffer),每个线程在Java堆中预先分配一小块内存，把内存分配的动作按线程划分在不同的空间进行。可以通过-XX：+/-UseTLAB参数来设定。
  
  + 栈上分配？
  
#### 内存溢出

  + Java堆内存溢出  
  
  Java堆存储对象实例，循环创建对象，并确保GC Roots到对象之间有可达路径，以此避免垃圾回收机制清除这些对象。那么当对象容量达到最大堆容量限制，则产生内存溢出异常。
  
  -Xms 设置最小堆内存，-Xmx设置最大堆内存
  
  ```java
  /**
   * args: -Xms20m -Xmx20m -XX: + HeapDumpOnOutOfMemoryError
   * 堆的内存溢出示例
   */
  public class HeapOOM {
  
    public static void main(String[] args) {
      List<HeapOOM> list = new ArrayList<>();
      while(true){
        list.add(new HeapOOM());
      }
    }
  }
  
//  Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
  ```
    
  + 虚拟机栈与本地方法栈溢出
  
  线程请求的栈深度大于虚拟机所允许最大深度时，将抛出StackOverflowError异常。
  
  虚拟机在扩展栈时无法申请到足够内存空间时，将抛出OOM异常。
  
  HotSpot虚拟机不区分虚拟机栈和本地方法栈。故-Xoss基本无用。-Xss参数设置栈容量。
  
  + 如何排查内存溢出。      
### JVM的类加载机制

### JVM的GC算法  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

### JVM

  内存溢出有哪几种？
  
  垃圾收集有哪几种算法？
  
  JVM调优有哪些参数。
  
  如何查看程序中的死循环，命令是什么？
  
  JVM的原理。
  
  JVM类加载机制。
  
  堆和栈的区别
  
  jdk、jre，日志分析jconsole。
  
  jstack。
  
  内存模型，对象创建过程