---
title: 多线程学习(三)：多线程中的Synchronized
date: 2018-11-13 16:40:30
categories:
- Java多线程
tags:
- Java
- 多线程
---

> 本节主要涉及Synchronized的使用，与Happen-Before的关系

## 参考资料

 **Java并发编程的艺术**

## 基本使用

 Synchronized可以修饰实例方法、静态方法和代码块。
 
 修饰实例方法时，针对当前实例加锁。
 
 修饰静态方法时，针对当前类对象加锁。
 
 修饰代码块时，指定加锁对象，对给定对象加锁。

<!-- more --> 

## Synchronized

### 特点

 Synchronized 是Java提供的强原子性的内置锁（也称为监视器锁）。 
 
 A线程尝试请求一个被线程B占有的锁时，线程A必须等待或者阻塞，知道B释放锁。
 
 Synchronized是可重入的。上例A请求B占有的锁必须等待，但B试图获取自己占有的锁则是被允许的。（比如子类重载父类的同步方法）

### 原理

 Synchonized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步
 
 ```java
    public class SynchronizedTest {
        public synchronized void test1(){
        }
        public void test2(){
            synchronized (this){
            }
        }
    }
 ```
 
 利用`javap -verbose SynchronizedTest.class`查看生成的class文件信息来分析Synchronized的实现。
 
 ![](http://pbsg2r9io.bkt.clouddn.com/18-11-14/35310750.jpg)
 
 从class信息查看，代码块同步是使用**monitorenter**和**monitorexit**指令实现同步的，方法同步依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。
 
 线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁。
 
 **Java对象监视器Monitor**
 
 锁也称对象监视器，多个线程请求某个对象监视器时，对象监视器会设置几种状态来区分请求的线程。
 
 + ContentionList: 所有请求锁的线程首先被放入竞争队列
 
 + Entry List: 竞争队列中有资格成为候选人的线程被移至EntryList。
 
 + Wait Set: 调用wait方法被阻塞的线程放在Wait Set。
 
 + OnDeck: 任何时刻最多只有一个线程竞争锁，该线程为OnDeck。
 
 + Owner: 获得锁的线程为Owner
 
 + !Owner: 释放锁的线程。
 
### 锁的升级
 
 锁的四种状态，优先级由低到高`无锁状态 < 偏向锁 < 轻量锁 < 重量级锁`
 
 锁的状态会随着竞争情况逐渐升级，锁允许升级但不允许降级。
 
 **偏向锁**
 
 偏向锁，其实是无锁竞争下可重入锁的简单实现。适用于一个线程访问同步锁的场景。
  
 > 当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁
 
 优点：减少了可重入锁的加解锁的额外消耗。
 
 大致流程：
 
 1. 线程A请求同步代码块，将自身ThreadId写入锁的ThreadId字段内，将对象头偏向锁的标识设置为1。
 
 2. 线程A后面再次进入同步块时，避免再次CAS操作来加解锁，直接对比对象锁的ThreadId字段证明自己已持有锁即可。
 
 > 偏向锁是一种等到竞争出现才会释放锁的机制，只有其他线程来竞争锁的时候，拥有锁的线程才会释放锁。
 
 3. 线程B准备进入同步块时，此时的偏向锁被A持有。线程B与线程A开始竞争锁。
 
   + 可能1： 重新偏向到线程B。
   
   + 可能2： 锁升级为轻量级锁，偏向锁撤销。（大部分情况是升级为轻量级锁）。
 
 > 此处有锁撤销、锁升级两个过程：
 >  锁撤销：
 >    1. 在安全点停止拥有锁的线程。
 >    2. 遍历线程栈，如果存在锁记录，则修复锁记录和Mark Word，使其变为无锁状态。
 >    3. 唤醒当前线程，将锁升级为轻量级锁。

 **轻量级锁**
 
 升级为轻量级锁有以下的步骤：
 
 1. 线程在自己的线程栈创建锁记录LockRecord。
 
 2. 复制锁对象的对象头到锁记录中。
 
 3. 将锁记录中的Owner指针指向锁对象。
 
 4. 将锁对象的对象头的Mark Word替换为指向锁记录的指针。
 
 轻量级锁分为：自旋锁和自适应自旋锁两种。
 
 轻量级锁在尝试加锁时，使用CAS尝试去执行第4步，操作成功则获取锁，操作失败则表示有线程竞争锁，当前线程会自旋来获取锁。
 
 当自旋获取锁依然失败时，锁升级为重量级锁。
   
## 名词释义

**竞态条件**
 
 设备或系统出现不恰当的执行时序，而得到不正确的结果。
 
 常见的静态条件有：
    
   + 检查再运行（惰性初始化）：单例。
   
   + 读-改-写：两个线程同时加100，总和可能小于200。
 
 > 为了避免竞态条件的出现，我们要保证操作的原子性。   
 
**数据竞争**
 
**锁膨胀**
 
 线程间竞争锁时，偏向锁失效，此时锁就会膨胀，升级为轻量级锁。
 
**锁撤销**
 
 当偏向锁失效时，就把偏向锁撤销