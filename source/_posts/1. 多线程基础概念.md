---
title: 多线程学习(一)：基础回顾
date: 2018-10-30 16:20:30
categories:
- Java多线程
tags:
- Java
- 多线程
---

> 学习实战Java高并发程序设计的读书笔记。
> 本章节的主要目的是对多线程的基础知识巩固了解一下。

## 参考书籍

 **实战Java高并发程序设计**
 
<!-- more -->

## 基础概念

**线程与进程**
 
 进程是系统进行资源分配和调度的一个独立单位。

 线程是进程中执行运算的最小单位，是被系统独立调度和分派的基本单位。线程不拥有系统资源。只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但它共享进程所拥有的全部资源。
 
**为什么使用多线程**
 
 + 资源利用率更好，CPU不会因为某个线程需要等待资源而进入空闲状态。
 
 + 程序设计更简单，程序响应更快。
 
**线程间如何通信**

 线程之间如何通信:共享内存和消息传递。
 
 + 在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。
 
 + 在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。
 
 Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。
 
**创建线程的方式**
 
 ```java
   // 方式1
   Thread t1 = new Thread();
   t1.start();
   
   //方式2
   public class RunnableTest implements Runnable{
      public void run() {
        System.out.println("runnable test");
      }
   Thread t2 = new Thread(new RunnableTest());
   t2.start();
 ```
 
**线程的生命周期**
 
 1. NEW 新建一个线程
 2. Runnable 调用start方法后，线程处于就绪状态，调用run方法后，线程处于运行状态。统称Runnable。
 3. Blocked  线程在等待锁的时候，状态处于Blocked，拿到锁恢复至Runnable。
 4. Waiting  
 5. Timed_Waiting 线程在Sleep等方法时，处于timed_waiting,Sleep后恢复至Runnable
 6. Terminated 线程执行完毕
 
**线程的常规方法**
 
 + start()/run() 通过start来开启线程，线程执行run方法。
 + interrupt()/isInterrupted()/interrupted() 
 
    interrupt() 通知目标线程中断，设置中断标志位**仅通知，需要线程自己中断**
    
    isInterrupted() 判断当前线程是否中断
    
    interrupted() 静态方法，判断当前线程是否中断，并清除标志位。
    
 + wait()/notify()/notifyAll() 都属于object类的方法
 
    wait()和notify、notifyAll首先都需要获取object的监视器。调用wait的线程会进入object的等待队列。等某个线程的object.notify执行后，
    
    随机等待被唤醒。notifyAll则是唤醒所有object等待队列中的线程。
 
 + join()/yield()
    
    join()阻塞当前线程，直到目标线程执行完毕。`t1.join()`线程t1加入main线程，main线程会等待t1线程执行结束。
    
    yield()静态方法，当前线程释放CPU资源，重新竞争。
    
**Daemon线程**
 
   后台守护线程，setDaemon(true)来设置，且在start()方法前，否则会报错且被当做一个普通线程。
   
**线程优先级**
 
   线程优先级在1-10之间设置，数字越大，优先级越高。
 
## 名词释义

 1. 并发与并行

  并发：多个任务交替执行
 
  并行：多个任务同时执行

  