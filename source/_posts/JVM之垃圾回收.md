---
title: JVM学习(三)：垃圾回收
date: 2018-10-28 14:46:30
categories:
- Java虚拟机
tags:
- Java
- Jvm
---

> 程序计数器、虚拟机栈、本地方法栈这些区域属线程私有，线程的分配与回收具有确定性。
> Java堆与方法区则不然，垃圾回收主要讨论的也是这部分。

<!-- more-->

## 对象回收判断

### 对象已死

 主要有两种算法判断对象是否已死。
 
 **引用计数算法**
 
  给对象添加一个引用计数器，有一个引用时，加1；引用失效时，计数器减1。计数器为0的对象即为不再被使用。
  
  优点：简单、效率高。
  
  缺点：很难解决对象间的循环引用。 (Java主流虚拟机中未使用该算法) 
 
 **可达性分析算法**
 
  通过一系列称为"GC Roots"的对象作为起始点，从GC Roots节点向下搜索，搜索的路径称为引用链(Reference Chain), 当某个对象到GC Roots没有任何引用链相连，则该对象不可用。
  
  Java中，可作为GC Roots对象的包括以下几种：
 
  + 虚拟机栈(栈帧中的本地变量表)中引用的对象。
  + 方法区中类静态属性引用的对象。
  + 方法区中常量引用的对象。
  + 本地方法栈中JNI(Native方法)引用的对象。

### 对象死亡标记

  在可达性算法分析中不可达的对象，暂时还没有死亡。死亡之前还有两次标记过程。
   
  对象不可达时，虚拟机会对该对象第一次打上标记，判断对象是否重写finalize方法。
  
   + 如果重写则将其放入一个F-Queue,稍后会有一个Finalizer线程执行它(对象在这里可以逃脱)。
  
   + 如果没有重写或方法已执行，则被过滤。

### 对象引用

  **强引用**
  
  垃圾收集器永远不会回收掉被引用的对象。
  
  **软引用**
  
  SoftReference 在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。
  
  **弱引用**
  
  WeakReferenc 当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
  
  **虚引用**
  
  PhantomReference 在这个对象被收集器回收时收到一个系统通知。      
     
## 垃圾回收算法

### 标记-清除

  最基础的垃圾收集算法，后续的所有收集算法都是基于这种方法的改进。
  
  标记所有需要回收的对象，标记完以后统一回收。（标记过程见4.1）
  
  缺点：
    
   1. 效率低
   2. 空间问题。标记-清除会产生大量的不连续内存碎片，当程序后续需要分配较大对象时，可能会因无法找到足够的连续内存提前触发GC。   
  
  ![](http://pbsg2r9io.bkt.clouddn.com/18-8-8/80407106.jpg)

### 复制

  将内存等分A/B两份， 触发GC时，将A中存活的对象复制到B，然后将A全部清理掉。
  
  优点：简单、高效
  
  缺点：内存空间变为一半，代价太高。
  
  ![](http://pbsg2r9io.bkt.clouddn.com/18-8-8/45488501.jpg)
  
  目前，商业虚拟机回收新生代使用的该算法。HotSpot虚拟机默认Eden:Survivor=8:1, 这里内存划分了一块Eden空间和两块Survivor空间。
  
  所以每次新生代可用内存为整个新生代容量的90%。只有10%的空间浪费。
  
  （如此划分是因为研究表明新生代对象98%是可回收的，所以每次GC会将Eden和Survivor的对象复制到10%的另一块Survivor中）

### 标记-整理

  根据老年代的特点，提出的标记-整理算法。
  
  标记过程与标记-清除算法类似，后续则是将存活对象往一端移动，GC时直接清理掉端边界以外的内存。
  
  ![](http://pbsg2r9io.bkt.clouddn.com/18-8-8/95829161.jpg)

### 分代收集算法

  当前商业虚拟机都是采用分代收集算法(Generational Collection)，不同区域选择不同的算法。
  
  Java堆-新生代：对象存活率低，使用复制算法。
  Java堆-老年代：对象存活率高，没有额外空间进行分配担保，使用标记-清除或标记-整理算法。

### HotSpot的算法实现

  **Stop the World**

  可达性分析，为确保分析期间，对象的引用关系不再发生变化。所以GC时，必须停顿所有Java执行线程。
  
  本章节暂时不做整理，后续再学习。


## 垃圾收集器

**Serial收集器(新生代、单线程、复制算法)**

单线程收集器，虚拟机运行在Client模式下的默认新生代收集器。

优点： 简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。

缺点：它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束

**ParNew收集器(新生代、多线程、复制算法)**

Serial收集器的多线程版本，运行在Server模式下的虚拟机中首选的新生代收集器。还有一个很重要的原因是，除Serial收集器，目前只有它可以与CMS收集器配合工作。

**Parallel Scavenge收集器(新生代、多线程、复制算法)**

并行的多线程收集器，和ParNew类似。唯一的区别在于ParNew关注GC停顿点，而它则关注于吞吐量(吞吐量=运行用户代码时间/（运行用户代码时间+GC时间）)。

> GC停顿点的缩短适用于客户端交互式应用，良好的响应速度可以提升用户的体验。
> 吞吐量的提升则可以高效利用CPU，尽快完成运算任务，适合没有太多交互的后台任务。

**Serial Old收集器(老年代、单线程、标记-整理算法)**

Serial收集器的老年代版本。主要用于Client模式的虚拟机。

**Parallel Old收集器(老年代、多线程、标记-整理算法)**

### CMS收集器

  CMS（Concurrent Mark Sweep）收集器，是一种以获取最短回收时间为目标的收集器。在当下重视服务响应速度的互联网应用和B/S系统的服务端，CMS非常符合。
  
  它的过程主要是：初始标记、并发标记、重新标记、并发清除。
  
  缺点：
  
   1. CMS收集器对CPU资源非常敏感。
   2. CMS无法处理浮动垃圾。可能会导致“Concurrent Mode Failure”失败而出现一次“Full GC”。
   3. 基于标记-清除的算法会产生大量空间碎片。

### G1收集器           

  G1(Garbage-First)收集器是当今收集器的最前言的成果之一。与其他收集器相比，它有以下几个特点：
  
  1. 并行与并发，G1可以充分利用多核来缩短Stop-The-World的时间。且可以并发让程序继续执行。
  2. 分代收集。
  3. 空间整合。G1整体采用标记-整理算法，局部(Region)间采用复制算法来收集。意味着G1在收集期间不会产生内存空间碎片。
  4. 可预测的停顿。这是G1相对CMS的另一优势。